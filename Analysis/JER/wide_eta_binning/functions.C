#include <iostream>
#include <fstream>
#include <TChain.h>
#include <TCanvas.h>
#include <TF1.h>
#include <TH1F.h>
#include <TH2F.h>
#include <TLatex.h>
#include <TFile.h>
#include <TLine.h>
#include <TStyle.h>
#include <string>
#include <TMath.h>
#include <TLegend.h>
#include <TPaveStats.h>
#include <TProfile.h>

#include <TGraphAsymmErrors.h>

#include <TGraphErrors.h>
#include <TMinuit.h>
#include <TMatrixD.h>

// Code of Andrea Malara
// Based on code by Marek Niedziela, Matthias Schr√∂der, Kristin Goebel

// Smeared MC instead of data:
//bool smeared = true;
TString labeldata = "Data";
//TString labeldata = "Smeared MC";
TString sep = "|";

struct fit_data{
  // x, y values:
  std::vector<double> x_val, y_val;
  // variance-covariance matrix for y values:
  TMatrixD y_cov;
  // inverted cov matrix; calculated by chi2_linear "on demand".
  TMatrixD y_cov_inv;

  void reset() {
    x_val.clear();
    y_val.clear();
    y_cov.ResizeTo(0,0);
    y_cov_inv.ResizeTo(0,0);
  }

  void CheckPoints() {
    std::vector<int> RemovedPoints;
    TMatrixD y_cov_new;
    int j = 0;

    for(unsigned int i = 0; i < y_val.size(); i++) {
      //         std::cout << "i: " << i << "   j: " << j << std::endl;
      if ( y_val.at(i) == 0) {
        x_val.erase(x_val.begin()+i);
        y_val.erase(y_val.begin()+i);
        RemovedPoints.push_back(j);
        i = i-1;
      }
      j++;
    }

    y_cov_new.ResizeTo(x_val.size(),x_val.size());
    for(unsigned int i=0; i < x_val.size(); i++) {
      for(unsigned int k= 0; k < x_val.size(); k++) {
        y_cov_new(i,k) = y_cov(i+RemovedPoints.size(),k+RemovedPoints.size());
      }
    }
    y_cov.ResizeTo(0,0);
    y_cov.ResizeTo(x_val.size(),x_val.size());
    y_cov = y_cov_new;
  }
};

fit_data data_;

void histLoadAsym( TFile &f, bool data, TString text, std::vector< std::vector< std::vector< TH1F* > > > &Asymmetry, std::vector< std::vector< std::vector< TH1F* > > > &GenAsymmetry, int etaBins, int ptBins, int AlphaBins, int etaShift);
void histMeanPt( std::vector< std::vector< std::vector< TH1F* > > > &Asymmetry , std::vector< std::vector< std::vector< double > > > &Widths );
void histWidthAsym_old( std::vector<std::vector<std::vector<TH1F*> > > &Asymmetry , std::vector<std::vector<std::vector<double> > > &Widths, std::vector<std::vector<std::vector<double> > > &WidthsError , bool fill_all );
void histWidthAsym( std::vector< std::vector< std::vector< TH1F* > > > &Asymmetry , std::vector< std::vector< std::vector< double > > > &Widths, std::vector< std::vector< std::vector< double > > > &WidthsError , bool fill_all, double alpha, bool isFE, std::vector< std::vector< std::vector< double > > > &lower_x, std::vector< std::vector< std::vector< double > > > &upper_x);
void histWidthMCTruth( std::vector<std::vector<std::vector<TH1F*> > > &Asymmetry , std::vector<std::vector<std::vector<double> > > &Widths, std::vector<std::vector<std::vector<double> > > &WidthsError );
void fill_widths_hists( TString name1, std::vector< std::vector< TH1F* > > &widths , std::vector< std::vector< std::vector< double > > > Widths, std::vector< std::vector< std::vector< double > > > WidthsError);
void histLinFit( std::vector< std::vector< TH1F* > > widths_hist_all , std::vector< std::vector< double > > &Widths, std::vector< std::vector< double > > &WidthsError, bool isFE );
void histLinCorFit( std::vector< std::vector< std::vector< double > > > Widths, std::vector< std::vector< std::vector< double > > > WidthsError, std::vector< std::vector< TGraphErrors* > > &output_graph, std::vector< std::vector< double > > &output, std::vector< std::vector< double > > &output_error, bool isFE, bool isMC, TH1F* h_chi2_tot);
void widths_015_ratios( TString name1, std::vector<TH1F*> &widths, std::vector<std::vector<std::vector<double> > > Widths, std::vector<std::vector<std::vector<double> > > WidthsError, std::vector<std::vector<std::vector<double> > > WidthsTwo, std::vector<std::vector<std::vector<double> > > WidthsTwoError, std::vector<std::vector<std::vector<double> > > forward_width_pt );
void correctJERwithPLI(std::vector< std::vector< double > > &Output, std::vector< std::vector< double > > &OutputError, std::vector< std::vector< double > > Widths, std::vector< std::vector< double > > WidthsError, std::vector< std::vector< double > > PLI, std::vector< std::vector< double > > PLIError, float shift = 0.0);
void correctJERwithPLI015(std::vector<std::vector<double> > &Output, std::vector<std::vector<double> > &OutputError, std::vector<std::vector<std::vector<double> > > Widths, std::vector<std::vector<std::vector<double> > > WidthsError, std::vector<std::vector<std::vector<double> > > PLI, std::vector<std::vector< std::vector< double > > > PLIError, float shift = 0.0);
void correctForRef( TString name1, std::vector<std::vector<double> > &Output, std::vector<std::vector<double> > &OutputError, std::vector<std::vector<double> > Input, std::vector<std::vector<double> > InputError, std::vector<std::vector<std::vector<double> > > width_pt, int shift, TString outdir);
void makeScales( std::vector< std::vector< double > > &Output, std::vector< std::vector< double > > &OutputError, std::vector< std::vector< double > > Input1, std::vector< std::vector< double > > Input1Error, std::vector< std::vector< double > > Input2, std::vector< std::vector< double > > Input2Error );
void fill_mctruth_hist( TString name1, std::vector< TH1F* > &output, std::vector< std::vector< std::vector< double > > > Widths, std::vector< std::vector< std::vector< double > > > WidthsError, std::vector< std::vector< std::vector< double > > > pt_binning, double range);
void fill_hist( TString name1, std::vector< TH1F* > &output, std::vector< std::vector< double > > Widths, std::vector< std::vector< double > > WidthsError, std::vector< std::vector< std::vector< double > > > pt_binning, double range, int shift2 = 0);
void Fill_Map3D(std::vector< std::vector < std::vector < TH1F* > > > &Asymmetry, std::vector < TH2F* > &Map, std::vector < double > &eta_bins, std::vector < double > &pt_bins );
void make_lin_fit(double & slope, double & d_slope, double & offset, double & d_offset, double min_slope, double max_slope, double min_offset, double max_offset, double & chi2);
void chi2_linear(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* p, Int_t status);
double sumSquare(double a, double b);
double findMinMax(TH1F* JER, std::vector< std::vector< double > > pt_width, TF1* NSC_ratio, TF1* constfit, bool isMin);
void fitLin( TH1F &hist, double &width, double &error );
bool removePointsforWidth(bool isFE, int m, int p, int r);
bool removePointsforFit(bool isFE, int m, int p);
void chi2_calculation(Double_t& fval, Double_t* p);

void histLoadAsym( TFile &f, bool data, TString text, std::vector< std::vector< std::vector< TH1F* > > > &Asymmetry, std::vector< std::vector< std::vector< TH1F* > > > &GenAsymmetry, int etaBins, int ptBins, int AlphaBins, int etaShift) {
  for( int m = etaShift; m < etaBins+etaShift; m++ ) {
    std::vector< std::vector< TH1F* > > temp2;
    std::vector< std::vector< TH1F* > > temp2gen;
    for( int p = 0; p < ptBins; p++ ) {
      std::vector< TH1F* > temp1;
      std::vector< TH1F* > temp1gen;
      for( int r = 0; r < AlphaBins; r++ ) {
        TString name = text;                        name    += "_eta"; name     += m+1; name    += "_pt"; name    += p+1; name    += "_alpha"; name     += r+1;
        TString namegen = "gen_"; namegen += text;  namegen += "_eta"; namegen  += m+1; namegen += "_pt"; namegen += p+1; namegen += "_alpha"; namegen  += r+1;
        TH1F* h = (TH1F*)f.Get(name);
        if (h) h->Rebin(2);
        temp1.push_back(h);
        if (( TH1F* )f.Get( name ) == 0) {
          std::cout << "ERROR" << std::endl;
          std::cout << name << std::endl;
        }
        if ( data == false ) {
          TH1F* h_gen = (TH1F*)f.Get(namegen);
					if (h_gen) h_gen->Rebin(2);
          temp1gen.push_back(h_gen);
        }
      }
      temp2.push_back(temp1);
      if ( data == false ) temp2gen.push_back(temp1gen);
    }
    Asymmetry.push_back(temp2);
    if ( data == false ) GenAsymmetry.push_back(temp2gen);
  }
}


void histMeanPt( std::vector< std::vector< std::vector< TH1F* > > > &Asymmetry , std::vector< std::vector< std::vector< double > > > &Widths ) {
  for( unsigned int m = 0; m < Asymmetry.size(); m++ ) {
    std::vector< std::vector< double > > temp1;
    for( unsigned int p = 0; p < Asymmetry.at(m).size(); p++ ) {
      std::vector< double > temp2;
      for( unsigned int r = 0; r < Asymmetry.at(m).at(p).size(); r++ ) {
        temp2.push_back( (*Asymmetry.at(m).at(p).at(r)).GetMean() );
      }
      temp1.push_back(temp2);
    }
    Widths.push_back(temp1);
  }
}

void histWidthAsym( std::vector< std::vector< std::vector< TH1F* > > > &Asymmetry , std::vector< std::vector< std::vector< double > > > &Widths, std::vector< std::vector< std::vector< double > > > &WidthsError , bool fill_all, double alpha, bool isFE, std::vector< std::vector< std::vector< double > > > &lower_x, std::vector< std::vector< std::vector< double > > > &upper_x) {
  double asym;
  double asymerr;

  for( unsigned int m = 0; m < Asymmetry.size(); m++ ) {
    std::vector< std::vector< double > > temp2;
    std::vector< std::vector< double > > temp_error2;
    std::vector< std::vector< double > > temp2_lower_x, temp2_upper_x;
    for( unsigned int p = 0; p < Asymmetry.at(m).size() ; p++ ) {
      std::vector< double > temp1;
      std::vector< double > temp_error1;
      std::vector< double > temp1_lower_x, temp1_upper_x;
      for( unsigned int r = 0; r < Asymmetry.at(m).at(p).size(); r++ ) {
        // std::cout << "eta pt alpha bins " << m << ", " << p << ", " << r << std::endl;
        TH1F* temp_hist = (TH1F*) Asymmetry.at(m).at(p).at(r)->Clone();
        double low, up;
        if (temp_hist->Integral() > 0) {
          for (int i = 0; i <= temp_hist->GetNbinsX(); i++) {
               if (i < temp_hist->FindBin(-0.5) || i > temp_hist->FindBin(0.5)) {
        	temp_hist->SetBinContent(i,0);
      		}
    	  }
          temp_hist->ComputeIntegral();
          Double_t xq[2], yq[2];
          xq[0] = std::min(alpha, 1.-alpha);
          xq[1] = std::max(alpha, 1.-alpha);
          temp_hist->GetQuantiles(2, yq, xq);
          temp_hist->GetXaxis()->SetRange(temp_hist->FindBin(yq[0]), temp_hist->FindBin(yq[1]));
          asym = temp_hist->GetRMS();
          asymerr = temp_hist->GetRMSError();
          low = temp_hist->GetBinCenter(temp_hist->FindBin(yq[0])); up = temp_hist->GetBinCenter(temp_hist->FindBin(yq[1]));
        } else { asym = 0.; asymerr = 0.; low = 10.0; up = 10.0;};

        if (!fill_all) {
          if (removePointsforWidth(isFE, m, p, r)) { asym = 0.; asymerr = 0.; };
        }
        temp1.push_back( asym );
        temp_error1.push_back( asymerr );
        temp1_lower_x.push_back(low);
        temp1_upper_x.push_back(up);
      }
      temp2.push_back(temp1);
      temp_error2.push_back(temp_error1);
      temp2_lower_x.push_back(temp1_lower_x);
      temp2_upper_x.push_back(temp1_upper_x);
    }
    Widths.push_back(temp2);
    WidthsError.push_back(temp_error2);
    lower_x.push_back(temp2_lower_x);
    upper_x.push_back(temp2_upper_x);
  }
}

void histWidthMCTruth( std::vector<std::vector<std::vector<TH1F*> > > &Asymmetry , std::vector<std::vector<std::vector<double> > > &Widths, std::vector<std::vector<std::vector<double> > > &WidthsError ) {
  double asym;
  double asymerr;

  for( unsigned int m = 0; m < Asymmetry.size(); m++ ) {
    std::vector< std::vector< double > > temp2;
    std::vector< std::vector< double > > temp_error2;
    for( unsigned int p = 0; p < Asymmetry.at(m).size() ; p++ ) {
      std::vector< double > temp1;
      std::vector< double > temp_error1;
      for( unsigned int r = 0; r < Asymmetry.at(m).at(p).size(); r++ ) {
        asym    = ((*Asymmetry.at(m).at(p).at(r)).GetRMS())/TMath::Sqrt(2);
        asymerr = ((*Asymmetry.at(m).at(p).at(r)).GetRMSError())/TMath::Sqrt(2);
        temp1.push_back( asym );
        temp_error1.push_back( asymerr );
      }
      temp2.push_back(temp1);
      temp_error2.push_back(temp_error1);
    }
    Widths.push_back(temp2);
    WidthsError.push_back(temp_error2);
  }
}

void fill_widths_hists( TString name1, std::vector< std::vector< TH1F* > > &widths , std::vector< std::vector< std::vector< double > > > Widths, std::vector< std::vector< std::vector< double > > > WidthsError) {
  double aMax[] = { 0.05, 0.1, 0.15, 0.2, 0.25, 0.3 };
  double temp;
  for( unsigned int m = 0; m < Widths.size(); m++ ) {
    std::vector< TH1F* > temp1;
    for( unsigned int p = 0; p < Widths.at(m).size(); p++ ) {
      TString name_width = name1;
      name_width += "_eta"; name_width += m+1; name_width += "_pt"; name_width += p+1;
      // if (name1.Contains("_fe")) { name_width += m+2; }
      // else { name_width += m+1; }
      TH1F *h1 = new TH1F( name_width, name_width, 50, 0, 0.35 );
      h1 ->GetYaxis()->SetTitle("#sigma_{A}");	h1 ->GetXaxis()->SetTitle("#alpha_{max}"); h1 ->GetYaxis()->SetTitleOffset(1.);
      h1 -> Sumw2();
      for( unsigned int r = 0; r < Widths.at(m).at(p).size(); r++ ) {
        temp = Widths.at(m).at(p).at(r);
        if ( !(TMath::IsNaN(temp)) && temp != 0) h1 -> SetBinContent( h1 -> FindBin( aMax[ r ] ), Widths.at(m).at(p).at(r) );
        if ( !(TMath::IsNaN(temp)) && temp != 0) h1 -> SetBinError( h1 -> FindBin( aMax[ r ] ), WidthsError.at(m).at(p).at(r) );
      }
      h1 ->GetYaxis()-> SetRangeUser( 0., 0.3 );
      temp1.push_back(h1);
    }
    widths.push_back(temp1);
  }
}

void histLinFit( std::vector< std::vector< TH1F* > > widths_hist_all , std::vector< std::vector< double > > &Widths, std::vector< std::vector< double > > &WidthsError, bool isFE ) {
  for( unsigned int m = 0; m < widths_hist_all.size(); m++ ) {
    std::vector<double> temp2;
    std::vector<double> temp_error2;
    for( unsigned int p = 0; p < widths_hist_all.at(m).size(); p++ ) {
      double value, error;
      if ( widths_hist_all.at(m).at(p)->GetEntries() != 0 ) {
        fitLin( *( widths_hist_all.at(m).at(p) ), value, error );

        if (removePointsforFit(isFE, m, p)) {value = 0; error = 0;}

        temp2.push_back(value);
        temp_error2.push_back(error);
      } else {
        temp2.push_back(0.);
        temp_error2.push_back(0.);
      }
    }
    Widths.push_back(temp2);
    WidthsError.push_back(temp_error2);
  }
}

void histLinCorFit( std::vector< std::vector< std::vector< double > > > Widths, std::vector< std::vector< std::vector< double > > > WidthsError, std::vector< std::vector< TGraphErrors* > > &output_graph, std::vector< std::vector< double > > &output, std::vector< std::vector< double > > &output_error, bool isFE, bool isMC, TH1F* h_chi2_tot) {
  for( unsigned int m = 0; m < Widths.size(); m++ ) {
    // eta loop
    std::vector<TGraphErrors*> temp2_graph;
    std::vector<double> temp2;
    std::vector<double> temp_error2;
    for( unsigned int p = 0; p < Widths.at(m).size(); p++ ) {
      // p_T loop
      std::vector<float> alpha;
      alpha.push_back(0.05); alpha.push_back(0.1); alpha.push_back(0.15); alpha.push_back(0.20); alpha.push_back(0.25); alpha.push_back(0.3);
      std::vector<double> x,x_e;
      for(int ialpha=0; ialpha < 6; ++ialpha) {
        x.push_back(alpha.at(ialpha));
        x_e.push_back(0.);
      }
      TMatrixD y_cov_mc;
      y_cov_mc.ResizeTo(alpha.size(), alpha.size());
      for(unsigned int ialpha=0; ialpha < alpha.size(); ++ialpha) {
        for (unsigned int jalpha =0; jalpha < alpha.size(); jalpha++) {
          if ( ialpha <= jalpha ) {
            double n1_mc = pow(Widths.at(m).at(p).at(ialpha),2)/(2*pow(WidthsError.at(m).at(p).at(ialpha),2));
            double n2_mc = pow(Widths.at(m).at(p).at(jalpha),2)/(2*pow(WidthsError.at(m).at(p).at(jalpha),2));
            y_cov_mc(ialpha, jalpha) = pow(WidthsError.at(m).at(p).at(ialpha),2) * pow((n1_mc/n2_mc),2)*
            (Widths.at(m).at(p).at(ialpha)/Widths.at(m).at(p).at(jalpha));
          } else {
            double n1_mc = pow(Widths.at(m).at(p).at(jalpha),2)/(2*pow(WidthsError.at(m).at(p).at(jalpha),2));
            double n2_mc = pow(Widths.at(m).at(p).at(ialpha),2)/(2*pow(WidthsError.at(m).at(p).at(ialpha),2));
            y_cov_mc(ialpha, jalpha) = pow(WidthsError.at(m).at(p).at(jalpha),2) * pow((n1_mc/n2_mc),2)*
            (Widths.at(m).at(p).at(jalpha)/Widths.at(m).at(p).at(ialpha));
          }
        }
      }

      //create TGraphErrors from previously defined vectors
      TGraphErrors* extrapol_MC = new TGraphErrors(alpha.size(),&x[0],&Widths.at(m).at(p).at(0),&x_e[0],&WidthsError.at(m).at(p).at(0));
      TString name = "Graph_SM_eta";
      if (isFE) name = "Graph_FE_eta";
      name += m+1; name+="_pt"; name += p+1;
      extrapol_MC->SetName(name);

      // fit linear extrapolation function
      TF1 *lin_extrapol_mc = new TF1("lin_extrapol_mc","[0]+[1]*x",0,alpha.back()+0.05);

      // fit
      data_.reset();
      data_.x_val = x;
      data_.y_val = Widths.at(m).at(p);
      data_.y_cov.ResizeTo(alpha.size(), alpha.size());
      data_.y_cov = y_cov_mc;
      data_.CheckPoints();
      // choose start values for the fit
      // double slope = (Widths.at(m).at(p).at(Widths.at(m).at(p).size()-1) - Widths.at(m).at(p).at(Widths.at(m).at(p).size()-3))/(x.at(x.size()-1) - x.at(x.size()-3));
      // double offset = Widths.at(m).at(p).at(Widths.at(m).at(p).size()-1) - (slope*x.at(x.size()-1));
      double chi2 = -10.0;
      int ndf = Widths.at(m).at(p).size()-2;
      double slope  = 0.15;
      double offset = 0.05;
      double d_slope = slope;
      double d_offset = offset;
      double min_slope = 0.05;
      double max_slope = 0.5;
      double min_offset = 0.001;
      double max_offset = 0.15;
      if ( !isFE && m == 7 && p == 2) { min_slope = 0.15; max_offset = 0.08;}
      if ( !isFE && m == 7 && p == 6) { min_slope = 0.01; max_offset = 0.08;}
      if ( !isFE && m == 8 && p == 6) { min_slope = 0.09; max_offset = 0.045;}
      if ( !isFE && m >= 10&& p == 2) { max_offset = 0.4;}
      if (isFE&&isMC&&m==10&& p == 6) { min_slope = 0.13; max_offset = 0.06;}
      if (!isFE&&isMC&&m==7&& p == 6) { min_slope = 0.01; max_offset = 0.08; min_offset = 0.04;}
      if (!isFE&&isMC&&m==7&& p == 2) { min_slope = 0.15; max_offset = 0.08; min_offset = 0.06;}

      //         std::cout << "eta: " << m <<  ", p_T: " << p << std::endl;
      //         std::cout << "fit start values: " << "slope: " << slope << " offset: " << offset << std::endl;
      make_lin_fit(slope, d_slope, offset, d_offset, min_slope, max_slope, min_offset, max_offset, chi2);
      //         std::cout << "fit values: " << "slope: " << slope << " offset: " << offset << std::endl;
      lin_extrapol_mc->SetParameter(0, offset);
      lin_extrapol_mc->SetParError(0, d_offset);
      lin_extrapol_mc->SetParameter(1, slope);
      lin_extrapol_mc->SetParError(1, d_slope);
      lin_extrapol_mc->SetChisquare(chi2);//TODO: set the correct chi/2
      lin_extrapol_mc->SetNDF(ndf);
      extrapol_MC->GetListOfFunctions()->Add(lin_extrapol_mc);
      if (removePointsforFit(isFE, m, p)) {offset = 0; d_offset = 0; chi2 = -10; }

      h_chi2_tot->Fill(chi2/ndf);

      temp2.push_back(offset);
      temp_error2.push_back(d_offset);
      temp2_graph.push_back(extrapol_MC);
    }
    output.push_back(temp2);
    output_error.push_back(temp_error2);
    output_graph.push_back(temp2_graph);
  }
}

void widths_015_ratios( TString name1, std::vector<TH1F*> &widths, std::vector<std::vector<std::vector<double> > > Widths, std::vector<std::vector<std::vector<double> > > WidthsError, std::vector<std::vector<std::vector<double> > > WidthsTwo, std::vector<std::vector<std::vector<double> > > WidthsTwoError, std::vector<std::vector<std::vector<double> > > forward_width_pt ) {
  double temp, tempError;
  for( unsigned int m = 0; m < Widths.size(); m++ ) {
    TString name_width = name1;
    name_width += "_eta"; name_width += m+1;
    TH1F *hist = new TH1F( name_width, name_width, 1100, 0, 1100 );
    hist ->GetYaxis()->SetTitle();
    hist ->GetXaxis()->SetTitle("p_{T} [GeV]");
    hist -> GetYaxis()->SetRangeUser( 0, 2. );
    for( unsigned int p = 0; p < Widths.at(m).size(); p++ ) {
      if (WidthsTwo.at(m).at(p).at(2) != 0.) {
        temp = Widths.at(m).at(p).at(2)/WidthsTwo.at(m).at(p).at(2);
        // tempError = WidthsError.at(m).at(p).at(2)/WidthsTwo.at(m).at(p).at(2) + ( Widths.at(m).at(p).at(2) * WidthsTwoError.at(m).at(p).at(2) ) / ( WidthsTwo.at(m).at(p).at(2) * WidthsTwo.at(m).at(p).at(2) ) ;
        tempError = sumSquare(WidthsError.at(m).at(p).at(2)/WidthsTwo.at(m).at(p).at(2) , ( Widths.at(m).at(p).at(2) * WidthsTwoError.at(m).at(p).at(2) ) / ( WidthsTwo.at(m).at(p).at(2) * WidthsTwo.at(m).at(p).at(2) ) );
        hist -> SetBinContent( hist -> FindBin( forward_width_pt.at(m).at(p).at(2) ), temp );
        hist -> SetBinError( hist -> FindBin( forward_width_pt.at(m).at(p).at(2) ), tempError );
      }
    }
    widths.push_back(hist);
  }
}

void correctJERwithPLI(std::vector< std::vector< double > > &Output, std::vector< std::vector< double > > &OutputError, std::vector< std::vector< double > > Widths, std::vector< std::vector< double > > WidthsError, std::vector< std::vector< double > > PLI, std::vector< std::vector< double > > PLIError, float shift) {
  for( unsigned int i = 0; i < Widths.size(); i++ ) {
    std::vector< double > temp2;
    std::vector< double > temp_error2;
    for( unsigned int j = 0; j < Widths.at(i).size(); j++ ) {
      double temp;
      double temp_error;
      if (Widths.at(i).at(j) != 0. ) {
        // With PLI correction (change also alpha=015):
        temp = TMath::Sqrt(2)*TMath::Sqrt( Widths.at(i).at(j) * Widths.at(i).at(j) - (1.+shift)*PLI.at(i).at(j) * PLI.at(i).at(j) );
        // temp_error = ( Widths.at(i).at(j) * WidthsError.at(i).at(j) + (1.+shift)* PLI.at(i).at(j) * PLIError.at(i).at(j) )/temp;
        temp_error = TMath::Sqrt(2)*sumSquare( Widths.at(i).at(j) * WidthsError.at(i).at(j), (1.+shift)*PLI.at(i).at(j) * PLIError.at(i).at(j) )/temp;
      } else {
        temp = 0.;
        temp_error = 0.;
      }
      if ( TMath::IsNaN(temp) ) { temp = 0. ; temp_error = 0.; }
      temp2.push_back(temp);
      temp_error2.push_back(temp_error);
    }
    Output.push_back(temp2);
    OutputError.push_back(temp_error2);
  }
}

void correctJERwithPLI015(std::vector<std::vector<double> > &Output, std::vector<std::vector<double> > &OutputError, std::vector<std::vector<std::vector<double> > > Widths, std::vector<std::vector<std::vector<double> > > WidthsError, std::vector<std::vector<std::vector<double> > > PLI, std::vector<std::vector< std::vector< double > > > PLIError, float shift) {
  for( unsigned int i = 0; i < Widths.size(); i++ ) {
    std::vector< double > temp2;
    std::vector< double > temp_error2;
    for( unsigned int j = 0; j < Widths.at(i).size(); j++ ) {
      double temp;
      double temp_error;
      // With PLI correction (change also alpha=0):
      temp = TMath::Sqrt(2)*TMath::Sqrt( Widths.at(i).at(j).at(2) * Widths.at(i).at(j).at(2) - (1.+shift)* PLI.at(i).at(j).at(2) * PLI.at(i).at(j).at(2) );
      // temp_error = ( Widths.at(i).at(j).at(2) * WidthsError.at(i).at(j).at(2) + (1.+shift) * PLI.at(i).at(j).at(2) * PLIError.at(i).at(j).at(2) )/temp;
      temp_error = TMath::Sqrt(2)*sumSquare( Widths.at(i).at(j).at(2) * WidthsError.at(i).at(j).at(2) , (1.+shift) * PLI.at(i).at(j).at(2) * PLIError.at(i).at(j).at(2) )/temp;
      if ( TMath::IsNaN(temp) ) { temp = 0 ; temp_error = 0; }
      temp2.push_back(temp);
      temp_error2.push_back(temp_error);
    }
    Output.push_back(temp2);
    OutputError.push_back(temp_error2);
  }
}

void correctForRef( TString name1, std::vector<std::vector<double> > &Output, std::vector<std::vector<double> > &OutputError, std::vector<std::vector<double> > Input, std::vector<std::vector<double> > InputError, std::vector<std::vector<std::vector<double> > > width_pt, int shift, TString outdir) {
  double Ref, Probe, RefError, ProbeError, pT;

  TH1F *hist = new TH1F( name1+"_hist", name1+"_hist", 1100, 0, 1100 );
  hist ->GetYaxis()->SetTitle("#sigma_{A}");
  hist ->GetXaxis()->SetTitle("p_{T}");

  for( unsigned int p = 0; p < Input.at(0).size(); p++ ) {
    double temp = 0;
    double temp_error = 0;
    for (unsigned int i = 0; i < shift; i++) {
      temp += Input.at(i).at(p)/shift;
      temp_error += InputError.at(i).at(p)/shift;
    }
    if ( temp != 0 && !(TMath::IsNaN(temp))) {
      // pT = width_pt.at(0).at(p).at(5) ;
      pT = (double)(*std::max_element(width_pt.at(0).at(p).begin(),width_pt.at(0).at(p).end()));
      hist->SetBinContent(hist->FindBin(pT), temp);
      hist->SetBinError(  hist->FindBin(pT), temp_error );
    }
  }

  TCanvas* canv = new TCanvas("nscplot","nscplot",50,50,800,600);
  hist -> Draw();
  canv -> Print(outdir+"pdfy/JERs/reference"+name1+".pdf","pdf");
  canv -> Print(outdir+"pdfy/JERs/reference"+name1+".png","png");

  for( unsigned int m = 1; m < shift; m++ ) {
    std::vector< double > temp2;
    std::vector< double > temp_error2;

    for( unsigned int p = 0; p < Input.at(m).size(); p++ ) {
      double temp;
      double temp_error;

      if ( Input.at(m).at(p) != 0. ) {
        // pT = width_pt.at(m).at(p).at(5) ;
        pT = (double)(*std::max_element(width_pt.at(0).at(p).begin(),width_pt.at(0).at(p).end()));

        temp = Input.at(m).at(p);
        temp_error = InputError.at(m).at(p);

        if ( !(TMath::IsNaN(temp)) ) temp2.push_back(temp);
        else temp2.push_back(0.);
        if ( !(TMath::IsNaN(temp)) ) temp_error2.push_back(temp_error);
        else temp_error2.push_back(0.);
      }
      else { temp2.push_back(0.); temp_error2.push_back(0.); }
    }
    Output.push_back(temp2);
    OutputError.push_back(temp_error2);
  }


  for( unsigned int m = shift; m < Input.size() ; m++ ) {
    std::vector< double > temp2;
    std::vector< double > temp_error2;

    for( unsigned int p = 0; p < Input.at(m).size(); p++ ) {
      double temp;
      double temp_error;

      if ( Input.at(m).at(p) != 0. ) {
        // pT = width_pt.at(m).at(p).at(5) ;
        pT = (double)(*std::max_element(width_pt.at(0).at(p).begin(),width_pt.at(0).at(p).end()));

        Ref = hist->GetBinContent(hist->FindBin(pT));
        RefError = hist->GetBinError(hist->FindBin(pT));
        Probe = Input.at(m).at(p);
        ProbeError = InputError.at(m).at(p);

        temp = TMath::Sqrt( 2*Probe*Probe - Ref*Ref);
        temp_error = sumSquare(2*Probe*ProbeError, Ref*RefError )/temp;

        if ( !(TMath::IsNaN(temp)) ) temp2.push_back(temp);
        else temp2.push_back(0.);
        if ( !(TMath::IsNaN(temp)) ) temp_error2.push_back(temp_error);
        else temp_error2.push_back(0.);
      }
      else { temp2.push_back(0.); temp_error2.push_back(0.); }
    }
    Output.push_back(temp2);
    OutputError.push_back(temp_error2);
  }
  delete canv;
}



void makeScales( std::vector< std::vector< double > > &Output, std::vector< std::vector< double > > &OutputError, std::vector< std::vector< double > > Input1, std::vector< std::vector< double > > Input1Error, std::vector< std::vector< double > > Input2, std::vector< std::vector< double > > Input2Error ) {
  for( unsigned int i = 0; i < Input1.size(); i++ ) {
    std::vector< double > temp2;
    std::vector< double > temp_error2;
    for( unsigned int j = 0; j < Input1.at(i).size(); j++ ) {
      double temp;
      double temp_error;
      // Cut on scale factors not between 0.7 and 2
      //if ( (Input1.at(i).at(j)!=0.) && (Input2.at(i).at(j)!=0.) && Input1.at(i).at(j) / Input2.at(i).at(j)>0.7 && Input1.at(i).at(j) / Input2.at(i).at(j)<2. )
      if ( (Input1.at(i).at(j)!=0.) && (Input2.at(i).at(j)!=0.) ) {
        temp = Input1.at(i).at(j) / Input2.at(i).at(j);
        // temp_error = Input1Error.at(i).at(j) / Input2.at(i).at(j) + ( Input1.at(i).at(j) * Input2Error.at(i).at(j)) / ( Input2.at(i).at(j) * Input2.at(i).at(j) ) ;
        temp_error = sumSquare( Input1Error.at(i).at(j)/Input2.at(i).at(j) , ( Input1.at(i).at(j) * Input2Error.at(i).at(j)) / ( Input2.at(i).at(j) * Input2.at(i).at(j) ) ) ;
      } else { temp = 0.; temp_error = 0.; }
      if ( TMath::IsNaN(temp) ) { temp = 0.; temp_error = 0.; }
      temp2.push_back(temp);
      temp_error2.push_back(temp_error);
    }
    Output.push_back(temp2);
    OutputError.push_back(temp_error2);
  }
}


void fill_mctruth_hist( TString name1, std::vector< TH1F* > &output, std::vector< std::vector< std::vector< double > > > Widths, std::vector< std::vector< std::vector< double > > > WidthsError, std::vector< std::vector< std::vector< double > > > pt_binning, double range) {
  for( unsigned int m = 0; m <  Widths.size(); m++ ) {
    TString name_width = name1; name_width += m+1;
    TH1F *h1 = new TH1F( name_width, name_width, 1100, 0, 1100 );
    h1 ->GetYaxis()->SetTitle("#sigma_{MCTruth}");	h1 ->GetXaxis()->SetTitle("p_{T}");	h1 -> Sumw2();

    for( unsigned int p = 0; p <  Widths.at(m).size(); p++ ) {
      double pT = (double)(*std::max_element(pt_binning.at(m).at(p).begin(),pt_binning.at(m).at(p).end()));
      if ( ( !(TMath::IsNaN(Widths.at(m).at(p).at(5))) )      && Widths.at(m).at(p).at(5)!= 0. ) h1 -> SetBinContent( h1 -> FindBin(pT), Widths.at(m).at(p).at(5)      );
      if ( ( !(TMath::IsNaN(WidthsError.at(m).at(p).at(5))) ) && Widths.at(m).at(p).at(5)!= 0. ) h1 -> SetBinError(   h1 -> FindBin(pT), WidthsError.at(m).at(p).at(5) );
    }
    h1 ->GetYaxis()-> SetRangeUser( 0., range );
    output.push_back(h1);
  }
}


void fill_hist( TString name1, std::vector< TH1F* > &output, std::vector< std::vector< double > > Widths, std::vector< std::vector< double > > WidthsError, std::vector< std::vector< std::vector< double > > > pt_binning, double range, int shift2) {
  // int shift = 0;
  // if (name1.Contains("SF_")) {
  //   shift = 1;
  //   if (Widths.size() > 10) shift = 3;
  // }
  for( unsigned int m = 0; m <  Widths.size(); m++ ) {
    TString name = name1;
    name += m+1;
    TH1F *h1 = new TH1F( name, name, 1100, 0, 1100 );
    //std::cout << name1 << std::endl;;
    if (name1.Contains("SF_")) h1 ->GetYaxis()->SetTitle("Scale factor");
    else                       h1 ->GetYaxis()->SetTitle("#sigma_{JER}");
    h1 ->GetXaxis()->SetTitle("p_{T}");	h1 -> Sumw2();

    for( unsigned int p = 0; p <  Widths.at(m).size(); p++ ) {
      double pT = (double)(*std::max_element(pt_binning.at(m+shift2).at(p).begin(),pt_binning.at(m+shift2).at(p).end()));
      if ( ( !(TMath::IsNaN(Widths.at(m).at(p))) ) && Widths.at(m).at(p)!= 0. )      h1 -> SetBinContent(h1 -> FindBin(pT), Widths.at(m).at(p) );
      if ( ( !(TMath::IsNaN(WidthsError.at(m).at(p))) ) && Widths.at(m).at(p)!= 0. ) h1 -> SetBinError(  h1 -> FindBin(pT), WidthsError.at(m).at(p) );
    }
    h1 ->GetYaxis()-> SetRangeUser( 0., range );
    output.push_back(h1);
  }
}


void Fill_Map3D(std::vector< std::vector < std::vector < TH1F* > > > &Asymmetry, std::vector < TH2F* > &Map, std::vector < double > &eta_bins, std::vector < double > &pt_bins ) {
  for (unsigned int r = 0; r < 6; r++) {
    TString name = "Map_mean_"; name += r;
    TH2F* temp = new TH2F(name,name, pt_bins.size(), pt_bins.at(0), pt_bins.at(pt_bins.size()-1), eta_bins.size(), eta_bins.at(0), eta_bins.at(eta_bins.size()-1));
    // TH2F* temp = new TH2F(name,name, eta_bins.size(), &eta_bins[0], pt_bins.size(), &pt_bins[0]);
    Map.push_back(temp);
  }

  for (unsigned int m = 0; m < Asymmetry.size(); m++) {
    for (unsigned int p = 0; p < Asymmetry.at(m).size(); p++) {
      for (unsigned int r = 0; r < Asymmetry.at(m).at(p).size(); r++) {
        Map.at(r) -> SetBinContent( Map.at(r) -> FindBin(pt_bins[p]), Map.at(r) -> FindBin(eta_bins[m]), Asymmetry.at(m).at(p).at(r)->GetMean());
      }
    }
  }
}


void make_lin_fit(double & slope, double & d_slope, double & offset, double & d_offset, double min_slope, double max_slope, double min_offset, double max_offset, double & chi2) {
  TMinuit min;
  min.SetPrintLevel(-1);
  //min.SetPrintLevel(0);
  if (slope  < 0.05  || slope  > 0.5) slope  = 0.15;
  if (offset < 0.001 || offset > 0.1) offset = 0.05;
  int err = min.DefineParameter(0, "slope", slope, d_slope, min_slope, max_slope);
  assert(err==0);
  err = min.DefineParameter(1, "offset", offset, d_offset, min_offset, max_offset);
  assert(err==0);
  min.SetFCN(chi2_linear);
  min.mnmigr();
  min.GetParameter(0, slope, d_slope);
  min.GetParameter(1, offset, d_offset);
  Double_t par[2]; par[0] = slope; par[1] = offset;
  chi2_calculation(chi2, par);
}


void chi2_linear(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* p, Int_t status) {
  if (data_.y_cov_inv.GetNcols()==0) {
    double dummy;
    int ncols = data_.y_cov.GetNcols();
    data_.y_cov_inv.ResizeTo(ncols, ncols);
    data_.y_cov_inv = data_.y_cov.Invert(&dummy);
  }
  const size_t ndata = data_.x_val.size(); // number of data points in x,y graph to fit to
  std::vector<double> delta_y(ndata);
  for(size_t i=0; i<ndata; ++i) {
    delta_y[i] = data_.x_val[i]*p[0] + p[1] - data_.y_val[i];
  }
  // now calculate the chi2, i.e.
  //  dy^T * C^{-1} * dy
  // where C is the variance--covariance matrix and dy = (y_data - y_pred)
  // This could probably be implemented in ROOT, but it's so simple, we just do it here:
  fval = 0.0;
  for(size_t i=0; i<ndata; ++i) {
    for(size_t j=0; j<ndata; ++j) {
      fval += delta_y[i] * delta_y[j] * data_.y_cov_inv(i,j);
    }
  }
}


void chi2_calculation(Double_t& fval, Double_t* p) {
  if (data_.y_cov_inv.GetNcols()==0) {
    double dummy;
    int ncols = data_.y_cov.GetNcols();
    data_.y_cov_inv.ResizeTo(ncols, ncols);
    data_.y_cov_inv = data_.y_cov.Invert(&dummy);
  }
  const size_t ndata = data_.x_val.size(); // number of data points in x,y graph to fit to
  std::vector<double> delta_y(ndata);
  for(size_t i=0; i<ndata; ++i) {
    delta_y[i] = data_.x_val[i]*p[0] + p[1] - data_.y_val[i];
  }
  // now calculate the chi2, i.e.
  //  dy^T * C^{-1} * dy
  // where C is the variance--covariance matrix and dy = (y_data - y_pred)
  // This could probably be implemented in ROOT, but it's so simple, we just do it here:
  fval = 0.0;
  for(size_t i=0; i<ndata; ++i) {
    for(size_t j=0; j<ndata; ++j) {
      fval += delta_y[i] * delta_y[j] * data_.y_cov_inv(i,j);
    }
  }
}


double sumSquare(double a, double b) {
  return TMath::Sqrt(a*a + b*b);
}


void findExtreme(std::vector<TH1*> vec, double *x_min, double *x_max, double *y_min, double *y_max) {
  std::vector<double> x;
  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetXaxis()->GetXmin());}
  *x_min = *std::min_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetXaxis()->GetXmax());}
  *x_max = *std::max_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetMinimum());}
  *y_min = *std::min_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetMaximum());}
  *y_max = *std::max_element(x.begin(), x.end());
  x.clear();

  if ((*x_min) == (*x_max)) {
    *x_min = (*x_min)*0.9;
    *x_max = (*x_max)*1.2;
  }

  if ((*y_min) == (*y_max)) {
    *y_min = *y_min*0.9;
    *y_max = *y_max*1.2;
  }
}



void findExtreme2(std::vector<TH1*> vec, double *x_min, double *x_max, double *y_min, double *y_max) {
  std::vector<double> x;
  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetXaxis()->GetXmin());}
  *x_min = *std::min_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetXaxis()->GetXmax());}
  *x_max = *std::max_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetMinimum());}
  *y_min = *std::min_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetBinContent(vec.at(i)->GetMaximumBin()));}
  *y_max = *std::max_element(x.begin(), x.end());
  x.clear();

  if ((*x_min) == (*x_max)) {
    *x_min = (*x_min)*0.9;
    *x_max = (*x_max)*1.2;
  }

  if ((*y_min) == (*y_max)) {
    *y_min = *y_min*0.9;
    *y_max = *y_max*1.2;
  }
}


void findExtreme2(std::vector<TGraphErrors*> vec, double *x_min, double *x_max, double *y_min, double *y_max) {
  std::vector<double> x;
  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MinElement(vec.at(i)->GetN(),vec.at(i)->GetX()));}
  *x_min = *std::min_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MaxElement(vec.at(i)->GetN(),vec.at(i)->GetX()));}
  *x_max = *std::max_element(x.begin(), x.end());
  x.clear();

  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MinElement(vec.at(i)->GetN(),vec.at(i)->GetY()));}
  *y_min = *std::min_element(x.begin(), x.end());
  x.clear();

  // for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetBinContent(vec.at(i)->GetMaximumBin()));}
  // for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetHistogram()->GetMaximum());}
  // for (int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetHistogram()->GetBinContent(vec.at(i)->GetHistogram()->GetMaximumBin()));}
  for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MaxElement(vec.at(i)->GetN(),vec.at(i)->GetY()));}
  *y_max = *std::max_element(x.begin(), x.end());
  x.clear();

  if ((*x_min) == (*x_max)) {
    *x_min = (*x_min)*0.9;
    *x_max = (*x_max)*1.2;
  }

  if ((*y_min) == (*y_max)) {
    *y_min = *y_min*0.9;
    *y_max = *y_max*1.2;
  }

  if (*x_min >= *x_max ||  *y_min >= *y_max)
  {
    cout << "Aiuto" << endl;
  }
}



template<typename TT>
void findExtreme_gr(std::vector<TT*> vec, double *x_min, double *x_max, double *y_min, double *y_max) {
  std::vector<double> x;
  // if (std::is_same<TT, TH1F>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetXaxis()->GetXmin());}
  if (std::is_same<TT, TGraphErrors>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MinElement(vec.at(i)->GetN(),vec.at(i)->GetX()));}
  *x_min = *std::min_element(x.begin(), x.end());
  x.clear();

  // if (std::is_same<TT, TH1F>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetXaxis()->GetXmax());}
  if (std::is_same<TT, TGraphErrors>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MaxElement(vec.at(i)->GetN(),vec.at(i)->GetX()));}
  *x_max = *std::max_element(x.begin(), x.end());
  x.clear();


  // if (std::is_same<TT, TH1F>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetMinimum());}
  if (std::is_same<TT, TGraphErrors>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MinElement(vec.at(i)->GetN(),vec.at(i)->GetY()));}
  *y_min = *std::min_element(x.begin(), x.end());
  x.clear();

  // if (std::is_same<TT, TH1F>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(vec.at(i)->GetBinContent(vec.at(i)->GetMaximumBin()));}
  if (std::is_same<TT, TGraphErrors>::value) for (unsigned int i = 0; i < vec.size(); i++) {x.push_back(TMath::MaxElement(vec.at(i)->GetN(),vec.at(i)->GetY()));}
  *y_max = *std::max_element(x.begin(), x.end());
  x.clear();

  if ((*x_min) == (*x_max)) {
    *x_min = (*x_min)*0.9;
    *x_max = (*x_max)*1.2;
  }

  if ((*y_min) == (*y_max)) {
    *y_min = *y_min*0.9;
    *y_max = *y_max*1.2;
  }

}

double findMinMax(TH1F* JER, std::vector< std::vector< double > > pt_width, TF1* NSC_ratio, TF1* constfit, bool isMin) {
	double min = 10000;
  double max = 0;
	for (unsigned int p = 2; p < pt_width.size(); p++) {// TODO It's set to 2 just because in the following steps pt>2"bin are used
    double pT = (double)(*std::max_element(pt_width.at(p).begin(),pt_width.at(p).end()));
    if (JER->GetBinContent(JER->FindBin(pT))== 0.) continue;
		min = std::min(min, TMath::Abs(NSC_ratio->Eval(pT) - constfit->Eval(pT)));
    max = std::max(min, TMath::Abs(NSC_ratio->Eval(pT) - constfit->Eval(pT)));
	}
  if (isMin) return min;
  else return max;
}

void fitLin( TH1F &hist, double &width, double &error ) {
  TF1 * linfit = new TF1( "linfit", "[0]+x*[1]", 0, 0.3 );
  linfit -> SetParameter( 0, 0.1 );
  linfit -> SetParameter( 1, 0.1 );
  linfit -> SetParLimits( 0, 0., 1. );
  hist.Fit( "linfit", "QM+" );
  width = linfit -> GetParameter(0);
  error = 1. * ( linfit -> GetParError(0) );
  delete linfit;
}



bool removePointsforWidth(bool isFE, int m, int p, int r) {
  bool check = false;
  if ( p == 0 && r < 4) check = true;
  if ( p == 1 && r < 4) check = true;
  if ( p == 2 && r < 3) check = true;
  if ( p == 3 && r < 2) check = true;
  if ( p == 4 && r < 1) check = true;
  if ( p == 5 && r < 1) check = true;
  if ( p == 6 && r < 1) check = true;
  if (!isFE   && m == 0 && p == 5 && r < 2) check = true;
  if (!isFE   && m == 1 && p >= 8 && r < 1) check = true;
  if (!isFE   && m == 2 && p == 7 && r < 1) check = true;
  if (!isFE   && m == 3 && p == 5 && r < 2) check = true;
  if (!isFE   && m == 4 && p == 8 && r < 1) check = true;
  if (!isFE   && m == 5 && p == 6 && r < 2) check = true;
  if (!isFE   && m == 5 && p == 7 && r < 1) check = true;
  if (!isFE   && m == 6 && p == 3 && r < 3) check = true;
  if (!isFE   && m == 6 && p == 4 && r < 2) check = true;
  if (!isFE   && m == 6 && p == 5 && r < 2) check = true;
  if (!isFE   && m == 6 && p == 9 && r < 1) check = true;
  if (!isFE   && m == 7 && p == 4 && r < 2) check = true;
  if (!isFE   && m == 7 && p == 6 && r < 2) check = true;
  if (!isFE   && m == 7 && p == 7 && r < 1) check = true;
  if (!isFE   && m == 7 && p == 8 && r < 1) check = true;
  if (!isFE   && m == 8 && p == 3 && r < 3) check = true;
  if (!isFE   && m == 8 && p == 4 && r < 2) check = true;
  if ( isFE   && m == 2 && p == 5 && r < 1) check = true;
  if ( isFE   && m == 6 && p == 8 && r < 2) check = true;
  if ( isFE   && m == 7 && p == 7 && r < 2) check = true;
  if ( isFE   && m == 8 && p == 3 && r < 3) check = true;
  if ( isFE   && m == 9 && p >= 7 && r < 1) check = true;
  if ( isFE   && m == 10&& p == 3 && r < 3) check = true;
  if ( isFE   && m == 10&& p == 7 && r < 1) check = true;
  if ( isFE   && m == 11&& p == 3 && r < 1) check = true;
  if ( isFE   && m == 11&& p == 7 && r < 2) check = true;
  if ( isFE   && m == 12&& p == 5 && r < 2) check = true;
  return check;
}


bool removePointsforFit(bool isFE, int m, int p) {
  bool check = false;
  if ( p<=1 ) check = true;
  if ( !isFE && m==5  && p==8 ) check = true;
  if ( !isFE && m==6  && p==8 ) check = true;
  if ( !isFE && m==7  && p>=8 ) check = true;
  if ( !isFE && m==8  && p>=5 ) check = true;
  if ( !isFE && m==9  && p>=5 ) check = true;
  if (  isFE && m==5  && p==2 ) check = true;
  if (  isFE && m==6  && p==8 ) check = true;
  if (  isFE && m==7  && p==7 ) check = true;
  if (  isFE && m==8  && p==2 ) check = true;
  if (  isFE && m==8  && p==7 ) check = true;
  if (  isFE && m==10 && p==6 ) check = true;
  if (  isFE && m==10 && p>=8 ) check = true;
  if (  isFE && m==11 && p>=7 ) check = true;
  if (  isFE && m==12 && p>=7 ) check = true;
  return check;
}
